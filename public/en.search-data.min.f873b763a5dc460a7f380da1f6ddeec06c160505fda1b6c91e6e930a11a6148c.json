[{"id":0,"href":"/docs/k8s/","title":"Docker and K8s","section":"Docs","content":" Introduction # "},{"id":1,"href":"/docs/golang/basics/variadic/","title":"Variadic Parameters and Argument Unpacking in Go","section":"Basics","content":" Variadic Parameters and Argument Unpacking in Go # In Go, variadic parameters and argument unpacking/expanding involve some specific behind-the-scenes mechanisms that allow for flexible and dynamic function calls. Here\u0026rsquo;s a detailed explanation of how these mechanisms work:\nVariadic Parameters # A variadic parameter allows a function to accept an arbitrary number of arguments. In Go, this is denoted by an ellipsis (...) followed by the type. For example:\nfunc sum(numbers ...int) int { total := 0 for _, number := range numbers { total += number } return total } In this sum function, numbers is a variadic parameter of type int. This means you can call sum with any number of integer arguments:\nresult := sum(1, 2, 3, 4) // result will be 10 How Variadic Parameters Work Behind the Scenes # Conversion to Slice: When a variadic function is called, the arguments passed to the variadic parameter are automatically converted into a slice of the specified type. In the example above, the arguments 1, 2, 3, 4 are converted into a slice []int{1, 2, 3, 4}.\nSlice Allocation: The Go runtime allocates memory for the slice that holds the variadic arguments. This slice is then passed to the function as if it were a regular slice parameter.\nAccessing Arguments: Inside the function, the variadic parameter can be used like a regular slice. You can iterate over it, access its length, and manipulate it just like any other slice.\nThe conversion of variadic arguments to a slice in Go is done at runtime, not during compilation. # When a variadic function is called with a series of arguments, the Go runtime performs the following steps:\nArgument Collection: The individual arguments passed to the variadic parameter are collected. Slice Creation: A new slice is created to hold these arguments. Element Copying: Each argument is copied into the newly created slice. Function Call: The function is called with the slice containing the variadic arguments. This process ensures that the function can handle an arbitrary number of arguments by treating them as a slice internally.\nArgument Unpacking/Expanding # Argument unpacking, or expanding, allows you to pass a slice to a variadic function as individual arguments. This is done using the ellipsis (...) syntax.\nFor example:\na := []int{1, 2, 3} result := sum(a...) // Equivalent to calling sum(1, 2, 3) How Argument Unpacking Works Behind the Scenes # Slice Decomposition: When you use the ... syntax with a slice, the compiler decomposes the slice into its individual elements.\nFunction Call Preparation: The decomposed elements are then passed to the function as if they were written out as individual arguments.\nVariadic Parameter Handling: The function receives these arguments, and they are automatically collected into a slice again, following the same mechanism as when variadic arguments are passed directly.\nExample # Consider the following complete example to illustrate both variadic parameters and argument unpacking:\npackage main import ( \u0026#34;fmt\u0026#34; ) func sum(numbers ...int) int { total := 0 for _, number := range numbers { total += number } return total } func main() { // Direct variadic arguments result1 := sum(1, 2, 3) fmt.Println(result1) // Output: 6 // Using a slice with variadic parameter a := []int{4, 5, 6} result2 := sum(a...) fmt.Println(result2) // Output: 15 } In main(), result1 is obtained by directly passing integers to sum, while result2 is obtained by passing a slice a using the ... syntax. Both ways demonstrate the flexibility and behind-the-scenes handling of variadic parameters and argument unpacking in Go.\nIn summary, Go\u0026rsquo;s handling of variadic parameters and argument unpacking involves converting arguments to slices, managing memory allocation, and allowing flexible function calls by decomposing slices into individual elements when necessary.\n"},{"id":2,"href":"/docs/golang/basics/newvsmake/","title":"Difference between `new` and `make` in Golang","section":"Basics","content":" Difference between new and make in Golang # In Go, make and new are built-in functions used for memory allocation.\nmake not only allocates memory but also initializes the data, which is necessary because the data types supported by make (like slices, maps, and channels) require initialization before use. On the other hand, new allocates memory space that is filled with zero values. new allocates a single block of memory, while make may allocate multiple blocks of memory. new # Usage: For basic types like integers, structs, and arrays. Returns: A pointer to the allocated type. Example:\npackage main import \u0026#34;fmt\u0026#34; func main() { p := new(int) fmt.Println(*p) // 0 *p = 42 fmt.Println(*p) // 42 type Person struct { Name string Age int } person := new(Person) fmt.Println(*person) // { 0} person.Name = \u0026#34;John\u0026#34; person.Age = 30 fmt.Println(*person) // {John 30} } make # Usage: For slices, maps, and channels. Returns: The initialized type itself. Example:\npackage main import \u0026#34;fmt\u0026#34; func main() { slice := make([]int, 5) fmt.Println(slice) // [0 0 0 0 0] for i := range slice { slice[i] = i + 1 } fmt.Println(slice) // [1 2 3 4 5] m := make(map[string]int) fmt.Println(m) // map[] m[\u0026#34;one\u0026#34;] = 1 m[\u0026#34;two\u0026#34;] = 2 fmt.Println(m) // map[one:1 two:2] ch := make(chan int, 2) fmt.Println(len(ch)) // 0 ch \u0026lt;- 1 ch \u0026lt;- 2 fmt.Println(len(ch)) // 2 } Key Differences # Types: new for any type, make for slices, maps, and channels. Return Value: new returns a pointer, make returns an initialized value. Initialization: new allocates zeroed storage, make allocates and initializes. "},{"id":3,"href":"/docs/golang/basics/emptystruct/","title":"Go Empty Struct","section":"Basics","content":" Go Empty Struct # Introduction # In Go, an empty struct struct{} can be puzzling. This article explores the empty struct\u0026rsquo;s properties and uses. An empty struct has zero memory allocation, identical addresses for multiple instances, and statelessness.\nZero Memory Allocation # Empty structs do not occupy memory, making them useful for memory optimization:\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;unsafe\u0026#34; ) func main() { var e struct{} fmt.Println(unsafe.Sizeof(e)) // Output: 0 } Identical Addresses # Multiple empty structs share the same address:\npackage main import \u0026#34;fmt\u0026#34; func main() { var e, e2 struct{} fmt.Printf(\u0026#34;%p\u0026#34;, \u0026amp;e) // Output: 0x90b418 fmt.Printf(\u0026#34;%p\u0026#34;, \u0026amp;e2) // Output: 0x90b418 } Usage Scenarios # Set Implementation: type Set[K comparable] map[K]struct{} func (s Set[K]) Add(val K) { s[val] = struct{}{} } Channel Signals: quit := make(chan struct{}) go func() { time.Sleep(3 * time.Second) close(quit) }() \u0026lt;-quit Method Receivers: type Person interface { SayHello() } type CMY struct{} func (c CMY) SayHello() { fmt.Println(\u0026#34;Hello, I\u0026#39;m Chen Mingyong.\u0026#34;) } "},{"id":4,"href":"/docs/leetcode/data-structure/hashmap/242validanagram/","title":"Leetcode 242 Valid Anagram","section":"Hashmap","content":" Leetcode 242: Valid Anagram # In this post, we will discuss how to solve the popular LeetCode problem: \u0026ldquo;Valid Anagram\u0026rdquo;. This problem requires us to determine if two given strings are anagrams of each other. Two strings are anagrams if they contain the same characters with the same frequencies.\nProblem Statement # Given two strings s and t, write a function isAnagram(s string, t string) bool that returns true if t is an anagram of s, and false otherwise.\nApproach to Solve the Problem # We can use a hashmap to count the number of each smallcase letter frequency, and then compare with the second string\nnote: it is all smallercase note: use an array slice to count frequency An illustration might help to explain this better, refer to\nImplementation in Go # Here\u0026rsquo;s the implementation of the above approach in Go:\nfunc isAnagram(s string, t string) bool { m := [26]int{} for _, v := range s { m[v-\u0026#39;a\u0026#39;]++ } for _, v := range t { m[v-\u0026#39;a\u0026#39;]-- } for _, v := range m { if v != 0 { return false } } return true } Explanation of the Code # Initialization: We initialize an array m of size 26 to zero. Each index in this array corresponds to a letter in the alphabet (\u0026lsquo;a\u0026rsquo; to \u0026lsquo;z\u0026rsquo;).\nCounting Characters in s: We iterate over each character v in the string s, calculate its position in the alphabet using v-'a', and increment the corresponding index in the array m.\nCounting Characters in t: Similarly, we iterate over each character v in the string t, calculate its position in the alphabet, and decrement the corresponding index in the array m.\nValidation: Finally, we check if all values in the array m are zero. If any value is not zero, it means the strings have different character frequencies and are not anagrams.\nConclusion # By using a frequency counter array, we efficiently determine if two strings are anagrams in linear time, O(n), where n is the length of the strings. This approach ensures that we check character frequencies in a simple and effective manner.\nHappy coding!\n"},{"id":5,"href":"/docs/golang/basics/closure/","title":"Understanding Closure Functions in Go","section":"Basics","content":" Understanding Closure Functions in Go # In Go, closure functions are powerful constructs that allow functions to capture and remember the variables from their surrounding scope even after that scope has exited. This capability is essential for creating more dynamic, flexible, and maintainable code. Let’s delve into closure functions with a simple example, understand why variables like sum are escaped to the heap, and explore their use cases in the standard library and web API development.\nA Simple Example: Summing Values # Consider the following example where we create a function that returns a closure to keep a running total of summed values:\npackage main import \u0026#34;fmt\u0026#34; func main() { adder := createAdder() fmt.Println(adder(1)) // Output: 1 fmt.Println(adder(2)) // Output: 3 fmt.Println(adder(3)) // Output: 6 } func createAdder() func(int) int { sum := 0 return func(x int) int { sum += x return sum } } In this example, createAdder returns an anonymous function (a closure) that captures and uses the variable sum from its outer function’s scope. Each call to adder updates sum and returns the new total.\nWhy sum is Escaped to the Heap # In Go, the compiler decides whether a variable should be allocated on the stack or heap. Variables captured by a closure need to live beyond the function call that created them. Normally, local variables like sum would reside on the stack, which is cleared when the function returns. However, because the closure needs to keep sum alive even after createAdder returns, the Go compiler automatically promotes sum to the heap. This process is known as variable escaping. The heap allocation ensures that sum persists and remains accessible to the closure as long as it is needed.\nUse Cases in the Standard Library # Closures are extensively used in the Go standard library. Here are a few examples:\nHTTP Handlers: The http.HandleFunc function uses closures to capture variables from the enclosing scope:\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;net/http\u0026#34; ) func main() { message := \u0026#34;Hello, World!\u0026#34; http.HandleFunc(\u0026#34;/\u0026#34;, func(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, message) }) http.ListenAndServe(\u0026#34;:8080\u0026#34;, nil) } Sorting: The sort.Slice function uses closures to define custom comparison logic:\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;sort\u0026#34; ) func main() { people := []struct { Name string Age int }{ {\u0026#34;Alice\u0026#34;, 23}, {\u0026#34;Bob\u0026#34;, 25}, {\u0026#34;Charlie\u0026#34;, 22}, } sort.Slice(people, func(i, j int) bool { return people[i].Age \u0026lt; people[j].Age }) fmt.Println(people) } Use Cases in Go Web API Development # In web API development, closures are invaluable for creating middleware and handlers that manage state and configuration. Here are a couple of common use cases:\nMiddleware:\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;net/http\u0026#34; ) func loggingMiddleware(next http.Handler) http.Handler { return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) { fmt.Println(\u0026#34;Request received\u0026#34;) next.ServeHTTP(w, r) }) } func main() { finalHandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) { w.Write([]byte(\u0026#34;Hello, World!\u0026#34;)) }) http.Handle(\u0026#34;/\u0026#34;, loggingMiddleware(finalHandler)) http.ListenAndServe(\u0026#34;:8080\u0026#34;, nil) } Handler with Configuration:\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;net/http\u0026#34; ) func createHandler(message string) http.HandlerFunc { return func(w http.ResponseWriter, r *http.Request) { fmt.Fprintf(w, message) } } func main() { http.HandleFunc(\u0026#34;/hello\u0026#34;, createHandler(\u0026#34;Hello, World!\u0026#34;)) http.HandleFunc(\u0026#34;/goodbye\u0026#34;, createHandler(\u0026#34;Goodbye, World!\u0026#34;)) http.ListenAndServe(\u0026#34;:8080\u0026#34;, nil) } Closures in Go enable powerful and flexible code patterns. By capturing and preserving variables, closures facilitate complex operations such as maintaining state across function calls, implementing custom behavior, and enhancing modularity and reusability in web applications. Understanding and leveraging closures can significantly improve the efficiency and readability of your Go programs.\n"},{"id":6,"href":"/docs/cs/internet/t2/","title":"What Happens When You Put a URL in Your Browser?","section":"Internet","content":" What Happens When You Put a URL in Your Browser? # Understanding what happens when you type a URL into your browser and hit enter is essential for grasping the basics of web technology. Here’s a detailed step-by-step breakdown of the process.\n1. URL Entry and Parsing # Input and Validation: When you enter a URL in the address bar, the browser first validates the URL to ensure it\u0026rsquo;s properly formatted. Protocol Identification: The browser identifies the protocol (e.g., HTTP, HTTPS) to determine how to communicate with the server. Domain Extraction: The browser extracts the domain name (e.g., www.example.com) from the URL. Path and Query Parsing: It also parses the path (e.g., /index.html) and any query parameters (e.g., ?id=123) in the URL. 2. DNS Resolution # Cache Check: The browser checks its cache for a recently resolved IP address for the domain. Operating System Cache: If not found, the browser queries the OS for the IP address. Recursive Querying: If the OS cache is empty, a DNS recursive query is sent to resolve the domain name into an IP address. DNS Server Interaction: The query goes to a DNS resolver, which might contact multiple DNS servers to find the authoritative DNS server for the domain. Response Handling: The DNS resolver eventually returns the IP address to the browser. 3. Establishing a Connection # TCP Handshake: The browser initiates a TCP connection with the server using a three-way handshake (SYN, SYN-ACK, ACK). Secure Connection (HTTPS): For HTTPS, a TLS handshake is performed to establish an encrypted connection. Certificate Verification: The server’s SSL certificate is verified to ensure it’s trusted and matches the domain. Key Exchange: Secure keys are exchanged to encrypt the communication between the browser and the server. 4. Sending an HTTP Request # Request Preparation: The browser prepares an HTTP request, specifying the method (GET, POST, etc.), URL path, headers, and possibly a body. Headers Inclusion: Headers include information like the User-Agent, Accept, and possibly cookies. Request Sending: The HTTP request is sent over the established connection to the server. Waiting for Response: The browser waits for the server’s response after sending the request. 5. Server Processing # Request Handling: The server receives and parses the HTTP request. Resource Fetching: The server determines the requested resource, which might involve fetching a static file, executing a script, or querying a database. Dynamic Content: For dynamic content, the server runs server-side code to generate the response. Response Preparation: The server prepares an HTTP response, including status codes, headers, and the response body. 6. Sending an HTTP Response # Response Transmission: The server sends the HTTP response back to the browser. Status Code Interpretation: The response includes a status code (e.g., 200 OK, 404 Not Found) indicating the result of the request. Headers and Caching: Headers provide metadata and caching instructions for the browser. Response Body: The body of the response contains the actual content, such as HTML, CSS, JavaScript, or JSON data. 7. Rendering the Content # HTML Parsing: The browser parses the HTML to build the Document Object Model (DOM). CSS Application: The browser applies CSS styles to the DOM to determine the layout and appearance. JavaScript Execution: JavaScript is executed to add interactivity and modify the DOM dynamically. Additional Requests: The browser makes additional HTTP requests for resources like images, stylesheets, and scripts. Content Painting: The parsed and styled content is painted onto the screen. 8. Displaying the Page # Final Rendering: The browser continuously repaints the screen as new content is received and processed. User Interaction: The browser handles user interactions like clicks, scrolls, and form submissions, triggering further HTTP requests if needed. DOM Updates: JavaScript may continue to update the DOM, causing re-renders and further user interaction handling. Performance Optimization: The browser optimizes performance by managing resource loading priorities and minimizing reflows. Conclusion # From entering a URL to displaying a web page, the process involves multiple detailed steps, including DNS resolution, establishing connections, sending requests, server processing, and rendering content. Each step is crucial in ensuring that the web page is correctly fetched and displayed to the user. Understanding these steps helps demystify the complexities behind a simple web request.\n"},{"id":7,"href":"/docs/cs/operating-system/t2/","title":"What Happens When You Put a URL in Your Browser?","section":"Operating System","content":" What Happens When You Put a URL in Your Browser? # Understanding what happens when you type a URL into your browser and hit enter is essential for grasping the basics of web technology. Here’s a detailed step-by-step breakdown of the process.\n1. URL Entry and Parsing # Input and Validation: When you enter a URL in the address bar, the browser first validates the URL to ensure it\u0026rsquo;s properly formatted. Protocol Identification: The browser identifies the protocol (e.g., HTTP, HTTPS) to determine how to communicate with the server. Domain Extraction: The browser extracts the domain name (e.g., www.example.com) from the URL. Path and Query Parsing: It also parses the path (e.g., /index.html) and any query parameters (e.g., ?id=123) in the URL. 2. DNS Resolution # Cache Check: The browser checks its cache for a recently resolved IP address for the domain. Operating System Cache: If not found, the browser queries the OS for the IP address. Recursive Querying: If the OS cache is empty, a DNS recursive query is sent to resolve the domain name into an IP address. DNS Server Interaction: The query goes to a DNS resolver, which might contact multiple DNS servers to find the authoritative DNS server for the domain. Response Handling: The DNS resolver eventually returns the IP address to the browser. 3. Establishing a Connection # TCP Handshake: The browser initiates a TCP connection with the server using a three-way handshake (SYN, SYN-ACK, ACK). Secure Connection (HTTPS): For HTTPS, a TLS handshake is performed to establish an encrypted connection. Certificate Verification: The server’s SSL certificate is verified to ensure it’s trusted and matches the domain. Key Exchange: Secure keys are exchanged to encrypt the communication between the browser and the server. 4. Sending an HTTP Request # Request Preparation: The browser prepares an HTTP request, specifying the method (GET, POST, etc.), URL path, headers, and possibly a body. Headers Inclusion: Headers include information like the User-Agent, Accept, and possibly cookies. Request Sending: The HTTP request is sent over the established connection to the server. Waiting for Response: The browser waits for the server’s response after sending the request. 5. Server Processing # Request Handling: The server receives and parses the HTTP request. Resource Fetching: The server determines the requested resource, which might involve fetching a static file, executing a script, or querying a database. Dynamic Content: For dynamic content, the server runs server-side code to generate the response. Response Preparation: The server prepares an HTTP response, including status codes, headers, and the response body. 6. Sending an HTTP Response # Response Transmission: The server sends the HTTP response back to the browser. Status Code Interpretation: The response includes a status code (e.g., 200 OK, 404 Not Found) indicating the result of the request. Headers and Caching: Headers provide metadata and caching instructions for the browser. Response Body: The body of the response contains the actual content, such as HTML, CSS, JavaScript, or JSON data. 7. Rendering the Content # HTML Parsing: The browser parses the HTML to build the Document Object Model (DOM). CSS Application: The browser applies CSS styles to the DOM to determine the layout and appearance. JavaScript Execution: JavaScript is executed to add interactivity and modify the DOM dynamically. Additional Requests: The browser makes additional HTTP requests for resources like images, stylesheets, and scripts. Content Painting: The parsed and styled content is painted onto the screen. 8. Displaying the Page # Final Rendering: The browser continuously repaints the screen as new content is received and processed. User Interaction: The browser handles user interactions like clicks, scrolls, and form submissions, triggering further HTTP requests if needed. DOM Updates: JavaScript may continue to update the DOM, causing re-renders and further user interaction handling. Performance Optimization: The browser optimizes performance by managing resource loading priorities and minimizing reflows. Conclusion # From entering a URL to displaying a web page, the process involves multiple detailed steps, including DNS resolution, establishing connections, sending requests, server processing, and rendering content. Each step is crucial in ensuring that the web page is correctly fetched and displayed to the user. Understanding these steps helps demystify the complexities behind a simple web request.\n"},{"id":8,"href":"/docs/cs/relational-db/t2/","title":"What Happens When You Put a URL in Your Browser?","section":"Relational Db","content":" What Happens When You Put a URL in Your Browser? # Understanding what happens when you type a URL into your browser and hit enter is essential for grasping the basics of web technology. Here’s a detailed step-by-step breakdown of the process.\n1. URL Entry and Parsing # Input and Validation: When you enter a URL in the address bar, the browser first validates the URL to ensure it\u0026rsquo;s properly formatted. Protocol Identification: The browser identifies the protocol (e.g., HTTP, HTTPS) to determine how to communicate with the server. Domain Extraction: The browser extracts the domain name (e.g., www.example.com) from the URL. Path and Query Parsing: It also parses the path (e.g., /index.html) and any query parameters (e.g., ?id=123) in the URL. 2. DNS Resolution # Cache Check: The browser checks its cache for a recently resolved IP address for the domain. Operating System Cache: If not found, the browser queries the OS for the IP address. Recursive Querying: If the OS cache is empty, a DNS recursive query is sent to resolve the domain name into an IP address. DNS Server Interaction: The query goes to a DNS resolver, which might contact multiple DNS servers to find the authoritative DNS server for the domain. Response Handling: The DNS resolver eventually returns the IP address to the browser. 3. Establishing a Connection # TCP Handshake: The browser initiates a TCP connection with the server using a three-way handshake (SYN, SYN-ACK, ACK). Secure Connection (HTTPS): For HTTPS, a TLS handshake is performed to establish an encrypted connection. Certificate Verification: The server’s SSL certificate is verified to ensure it’s trusted and matches the domain. Key Exchange: Secure keys are exchanged to encrypt the communication between the browser and the server. 4. Sending an HTTP Request # Request Preparation: The browser prepares an HTTP request, specifying the method (GET, POST, etc.), URL path, headers, and possibly a body. Headers Inclusion: Headers include information like the User-Agent, Accept, and possibly cookies. Request Sending: The HTTP request is sent over the established connection to the server. Waiting for Response: The browser waits for the server’s response after sending the request. 5. Server Processing # Request Handling: The server receives and parses the HTTP request. Resource Fetching: The server determines the requested resource, which might involve fetching a static file, executing a script, or querying a database. Dynamic Content: For dynamic content, the server runs server-side code to generate the response. Response Preparation: The server prepares an HTTP response, including status codes, headers, and the response body. 6. Sending an HTTP Response # Response Transmission: The server sends the HTTP response back to the browser. Status Code Interpretation: The response includes a status code (e.g., 200 OK, 404 Not Found) indicating the result of the request. Headers and Caching: Headers provide metadata and caching instructions for the browser. Response Body: The body of the response contains the actual content, such as HTML, CSS, JavaScript, or JSON data. 7. Rendering the Content # HTML Parsing: The browser parses the HTML to build the Document Object Model (DOM). CSS Application: The browser applies CSS styles to the DOM to determine the layout and appearance. JavaScript Execution: JavaScript is executed to add interactivity and modify the DOM dynamically. Additional Requests: The browser makes additional HTTP requests for resources like images, stylesheets, and scripts. Content Painting: The parsed and styled content is painted onto the screen. 8. Displaying the Page # Final Rendering: The browser continuously repaints the screen as new content is received and processed. User Interaction: The browser handles user interactions like clicks, scrolls, and form submissions, triggering further HTTP requests if needed. DOM Updates: JavaScript may continue to update the DOM, causing re-renders and further user interaction handling. Performance Optimization: The browser optimizes performance by managing resource loading priorities and minimizing reflows. Conclusion # From entering a URL to displaying a web page, the process involves multiple detailed steps, including DNS resolution, establishing connections, sending requests, server processing, and rendering content. Each step is crucial in ensuring that the web page is correctly fetched and displayed to the user. Understanding these steps helps demystify the complexities behind a simple web request.\n"},{"id":9,"href":"/docs/golang/basics/set/","title":"How to implement set using hashmap in golang?","section":"Basics","content":" How to Implement Set Using HashMap in Golang # 1. What is a Set? How is Set Different from HashMap? # A set is a data structure that stores a collection of unique elements. Sets do not allow duplicate values and do not maintain any particular order of the elements.\nA hashmap is a data structure that stores key-value pairs. Each key in a hashmap is unique, and it maps to a specific value.\nDifferences between Set and HashMap: # Structure: A set can be thought of as a hashmap with only keys and no associated values. Use Case: Use a set when you need to ensure uniqueness of elements. Use a hashmap when you need to associate values with keys for quick lookup. 2. How to Implement Set Using HashMap in Golang? # In Golang, we can implement a set using a hashmap where the keys of the hashmap represent the elements of the set. The values of the hashmap can be of an empty struct type (struct{}) because it consumes no memory.\nExample Code: # func main() { set := make(map[int]struct{}) set[1] = struct{}{} set[2] = struct{}{} set[3] = struct{}{} if _, exists := set[1]; exists { fmt.Println(\u0026#34;1 exists in set\u0026#34;) } fmt.Println(set) delete(set, 3) fmt.Println(set) } 3. Why Not Use map[int]bool to Implement Set in Golang? # Using map[int]bool is a straightforward way to implement a set, but using map[int]struct{} has some advantages:\nMemory Efficiency: The struct{} type in Go occupies zero bytes of storage, while the bool type requires at least one byte. When dealing with a large number of elements, map[int]struct{} can save significant memory.\nSemantics: Using struct{} as the value type clearly indicates that the map is being used as a set where only the presence of keys matters. This can prevent misuse where the boolean value might be misinterpreted or used incorrectly.\n4. When Will I Need to Use Set? # Sets are useful in scenarios where you need to maintain a collection of unique elements and frequently check for the presence of elements. Some common use cases include:\nRemoving duplicates from a list. Checking for membership. Performing set operations like union, intersection, and difference. 5. Solution Example for LeetCode 349: Intersection of Two Arrays # Here\u0026rsquo;s an example of how to use sets to solve LeetCode problem 349, which requires finding the intersection of two arrays:\nfunc intersection(nums1 []int, nums2 []int) (intersection []int) { set1 := map[int]struct{}{} for _, v := range nums1 { set1[v] = struct{}{} } set2 := map[int]struct{}{} for _, v := range nums2 { set2[v] = struct{}{} } if len(set1) \u0026gt; len(set2) { set1, set2 = set2, set1 } for v := range set1 { if _, has := set2[v]; has { intersection = append(intersection, v) } } return } Explanation: # Create Sets: Create two sets, set1 and set2, to store the unique elements from nums1 and nums2 respectively. Fill Sets: Populate the sets with elements from the arrays. Optimize Search: Swap sets if set1 is larger than set2 to minimize the number of lookups. Find Intersection: Iterate through the smaller set and check if each element is present in the larger set. If it is, add it to the intersection result. 6. Template for finding intersections between 2 sets # if len(set1) \u0026gt; len(set2) { set1, set2 = set2, set1 } for v := range set1 { if _, has := set2[v]; has { intersection = append(intersection, v) } } This approach ensures that the intersection contains only unique elements that are present in both arrays, leveraging the efficiency of sets implemented using hashmaps.\n"},{"id":10,"href":"/docs/golang/basics/fmt/","title":"How to use golang fmt package?","section":"Basics","content":" formatting verbs # %s vs %q? Answer: %s prints the string without enclosing it in quotes. %q prints the string enclosed in double quotes, %q can print string, byte slice, runes and int. %v vs %+v vs %#v? Answer: %v: Default format, prints the value as is. For structs, it prints only the field values. %+v: Detailed format, includes field names in structs. %#v: Go-syntax representation, includes type information and can be used to recreate the value in Go code. What to use to print slice, maps and structs(composite data types)? Answer: %v, %+v, and %#v is mostly used %p prints the pointer of the complex data types scan function for user input # Scan, Scanf and Scanln read from os.Stdin Fscan, Fscanf and Fscanln read from a specified io.Reader Sscan, Sscanf and Sscanln read from an argument string Most importantly, remember to pass pointer instead of the variable as it needs to be written to the same variable space, not the value itself. Also, remember to handle errors with fmt.Scan functions If we want to do an endless input, we can use the for loop and break the loop if there is any error with the fmt.Scan Difference between fmt.Scan, fmt.Scanf and fmt.Scanln? Answer: fmt.Scan: Reads space-separated values from standard input. Stops reading at the first whitespace. var a int var b string fmt.Scan(\u0026amp;a, \u0026amp;b) fmt.Printf(\u0026#34;a: %d, b: %s\\n\u0026#34;, a, b) fmt.Scanf: Reads input according to a format specifier. Allows more control over the input format. var a int var b string fmt.Scanf(\u0026#34;%d %s\u0026#34;, \u0026amp;a, \u0026amp;b) fmt.Printf(\u0026#34;a: %d, b: %s\\n\u0026#34;, a, b) fmt.Scanln Reads input until a newline is encountered. Useful for reading a whole line of text or multiple values until the newline. var b string fmt.Scanln(\u0026amp;b) "},{"id":11,"href":"/posts/hugosite/","title":"Quick tutorial on blog web with hugo and netlify","section":"Blog","content":" How to Create a Blog with Hugo and Deploy on Netlify # Creating a blog with Hugo and deploying it on Netlify is a streamlined and efficient process. Hugo is a powerful static site generator that allows for quick and easy website development. Netlify provides seamless deployment and hosting for static sites. Here\u0026rsquo;s a step-by-step guide to get your blog up and running.\nPrerequisites # Install Hugo by following the installation guide. Start from the root folder of a github repo, such as yangblog Step 1: Create a New Hugo Site # Start by creating a new Hugo site:\nhugo new site yanglyublog --format yaml Step 2: Add a Theme # Choose a theme from the Hugo Themes site. For example, to add the Ananke theme:\ngit init git submodule add https://github.com/theNewDynamic/gohugo-theme-ananke.git themes/ananke echo \u0026#39;theme = \u0026#34;ananke\u0026#34;\u0026#39; \u0026gt;\u0026gt; hugo.yaml Step 3: Create Content # Generate your first post:\nhugo new posts/my-first-post.md Edit the content of the post by opening the content/posts/my-first-post.md file in a text editor. Change the draft status to false. You can also just create any .md file under content/posts/ Step 4: Build the Site # To see your site locally, run:\nhugo server --minify --theme hugo-book Visit http://localhost:1313 in your browser to preview the site.\nStep 5: Prepare for Deployment # Update the hugo.yaml file, update as follows: baseURL: https://yanglyublog.netlify.app/ languageCode: en-us title: Yang\u0026#39;s Blog theme: hugo-book Push your Hugo site to your repository. Read this blog here to understand the steps needed. Step 6: Deploy to Netlify # Go to Netlify and sign up or log in. Click on “New site from Git” and select your repository.\nConfigure the build settings:\nBuild Command: hugo --gc --minify Publish Directory: public Set Env Var:\nHUGO_VERSION: 0.128.2 Click “Deploy site.” Netlify will build and deploy your site. Once the process is complete, you will have a live URL for your new blog.\nStep 7: Continuous Deployment # Every time you push changes to your GitHub repository, Netlify will automatically rebuild and deploy your site. This ensures your blog is always up-to-date with the latest changes.\nConclusion # Creating and deploying a blog with Hugo and Netlify is straightforward. Hugo\u0026rsquo;s speed and flexibility combined with Netlify\u0026rsquo;s ease of use for deployment make it a powerful combination for bloggers and developers alike.\nEnjoy your new blog!\n"},{"id":12,"href":"/posts/domain/","title":"Setting Up a New Domain for Your Netlify Website","section":"Blog","content":" Setting Up a New Domain for Your Netlify Website # Setting up a custom domain for your Netlify website helps in branding and makes it easier for users to find your site. Here’s a step-by-step guide on how to set up a new domain for your Netlify website.\nStep 1: Purchase a Domain # First, you need to purchase a domain from a domain registrar. Some popular domain registrars include:\nNamecheap GoDaddy Google Domains Choose a domain name that reflects your brand or website’s purpose.\nStep 2: Add a Custom Domain in Netlify # Log in to Netlify: Go to Netlify and log in to your account. Select Your Site: From your Netlify dashboard, select the site you want to add a custom domain to. Go to Domain Settings: In the site dashboard, navigate to the \u0026ldquo;Domain settings\u0026rdquo; section under \u0026ldquo;Site settings.\u0026rdquo; Add Custom Domain: Click on the \u0026ldquo;Add custom domain\u0026rdquo; button and enter your purchased domain name. Step 3: Configure DNS Settings # Access DNS Settings in Netlify: After adding your custom domain, Netlify will provide you with DNS records that need to be added to your domain registrar. Log in to Your Domain Registrar: Log in to the account where you purchased your domain. Find DNS Settings: Navigate to the DNS settings or domain management section of your registrar. Add DNS Records: Add the DNS records provided by Netlify. These typically include an A record pointing to Netlify’s IP address and a CNAME record for www. Example DNS Records # A Record: Name: @ Value: 104.198.14.52 CNAME Record: Name: www Value: your-site.netlify.app Step 4: Verify DNS Configuration # Wait for Propagation: DNS changes can take some time to propagate (usually up to 48 hours, but often much quicker). Check Status: Return to the Netlify dashboard and check the status of your domain under the \u0026ldquo;Domain settings\u0026rdquo; section. Netlify will verify the DNS configuration. HTTPS Configuration: Once your DNS is configured correctly, Netlify will automatically provision an SSL certificate for your domain, enabling HTTPS. Step 5: Redirect Non-www to www (or vice versa) # Domain Aliases: In the \u0026ldquo;Domain settings,\u0026rdquo; you can set up domain aliases to ensure both www.yourdomain.com and yourdomain.com point to your site. Primary Domain: Choose your primary domain in the Netlify settings to redirect traffic from the non-primary domain to the primary one. Conclusion # Setting up a custom domain for your Netlify website enhances your brand\u0026rsquo;s credibility and makes your site more accessible to your audience. By following these steps, you can easily configure and manage your domain settings, ensuring your site is live and secure.\n"},{"id":13,"href":"/docs/k8s/docker/","title":"Docker","section":"Docker and K8s","content":" Ubi loqui # "},{"id":14,"href":"/docs/k8s/k8s/","title":"K8s","section":"Docker and K8s","content":" Ubi loqui # "},{"id":15,"href":"/docs/leetcode/data-structure/hashmap/","title":"Hashmap","section":"Data Structure","content":" Hashmap # High Frequency and High Importance # High Frequency and OK # Must Understand # Valid Anagram Intersections of two arrays (return without duplicates) two sums three sums four sums four sums II\n"},{"id":16,"href":"/posts/","title":"Blog","section":"Introduction","content":"Here are some personal blogs to document my journey\n"},{"id":17,"href":"/docs/leetcode/data-structure/linkedlist/23mergeklists/","title":"23mergeklists","section":"Linkedlist","content":" leetcode 23: merge k sorted linked list # Caesorum illa tu sentit micat vestes papyriferi # "},{"id":18,"href":"/docs/leetcode/data-structure/linkedlist/","title":"Linkedlist","section":"Data Structure","content":" LinkedList # Collections of LinkedList Questions\nHigh Frequency and High Importance # High Frequency and OK # Must Understand # "},{"id":19,"href":"/docs/shortcodes/buttons/","title":"Buttons","section":"Shortcodes","content":" Buttons # Buttons are styled links that can lead to local page or external link.\nExample # {{\u0026lt; button relref=\u0026#34;/\u0026#34; [class=\u0026#34;...\u0026#34;] \u0026gt;}}Get Home{{\u0026lt; /button \u0026gt;}} {{\u0026lt; button href=\u0026#34;https://github.com/alex-shpak/hugo-book\u0026#34; \u0026gt;}}Contribute{{\u0026lt; /button \u0026gt;}} Get Home Contribute "},{"id":20,"href":"/docs/shortcodes/columns/","title":"Columns","section":"Shortcodes","content":" Columns # Columns help organize shorter pieces of content horizontally for readability.\n{{\u0026lt; columns \u0026gt;}} \u0026lt;!-- begin columns block --\u0026gt; # Left Content Lorem markdownum insigne... \u0026lt;---\u0026gt; \u0026lt;!-- magic separator, between columns --\u0026gt; # Mid Content Lorem markdownum insigne... \u0026lt;---\u0026gt; \u0026lt;!-- magic separator, between columns --\u0026gt; # Right Content Lorem markdownum insigne... {{\u0026lt; /columns \u0026gt;}} Example # Left Content # Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.\nMid Content # Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter!\nRight Content # Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.\n"},{"id":21,"href":"/docs/shortcodes/details/","title":"Details","section":"Shortcodes","content":" Details # Details shortcode is a helper for details html5 element. It is going to replace expand shortcode.\nExample # {{\u0026lt; details \u0026#34;Title\u0026#34; [open] \u0026gt;}} ## Markdown content Lorem markdownum insigne... {{\u0026lt; /details \u0026gt;}} {{\u0026lt; details title=\u0026#34;Title\u0026#34; open=true \u0026gt;}} ## Markdown content Lorem markdownum insigne... {{\u0026lt; /details \u0026gt;}} Title Markdown content # Lorem markdownum insigne\u0026hellip;\n"},{"id":22,"href":"/docs/shortcodes/expand/","title":"Expand","section":"Shortcodes","content":" Expand # Expand shortcode can help to decrease clutter on screen by hiding part of text. Expand content by clicking on it.\nExample # Default # {{\u0026lt; expand \u0026gt;}} ## Markdown content Lorem markdownum insigne... {{\u0026lt; /expand \u0026gt;}} Expand ↕ Markdown content # Lorem markdownum insigne\u0026hellip;\nWith Custom Label # {{\u0026lt; expand \u0026#34;Custom Label\u0026#34; \u0026#34;...\u0026#34; \u0026gt;}} ## Markdown content Lorem markdownum insigne... {{\u0026lt; /expand \u0026gt;}} Custom Label ... Markdown content # Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.\n"},{"id":23,"href":"/docs/shortcodes/hints/","title":"Hints","section":"Shortcodes","content":" Hints # Hint shortcode can be used as hint/alerts/notification block.\nThere are 3 colors to choose: info, warning and danger.\n{{\u0026lt; hint [info|warning|danger] \u0026gt;}} **Markdown content** Lorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa {{\u0026lt; /hint \u0026gt;}} Example # Markdown content\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa Markdown content\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa Markdown content\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa "},{"id":24,"href":"/docs/shortcodes/mermaid/","title":"Mermaid","section":"Shortcodes","content":" Mermaid Chart # MermaidJS is library for generating svg charts and diagrams from text.\nOverride Mermaid Initialization Config\nTo override the initialization config for Mermaid, create a mermaid.json file in your assets folder!\nExample # {{\u0026lt; mermaid class=\u0026#34;optional\u0026#34; \u0026gt;}} stateDiagram-v2 State1: The state with a note note right of State1 Important information! You can write notes. end note State1 --\u0026gt; State2 note left of State2 : This is the note to the left. {{\u0026lt; /mermaid \u0026gt;}} stateDiagram-v2 State1: The state with a note note right of State1 Important information! You can write notes. end note State1 --\u003e State2 note left of State2 : This is the note to the left. "},{"id":25,"href":"/docs/shortcodes/section/","title":"Section","section":"Shortcodes","content":" Section # Section renders pages in section as definition list, using title and description. Optional param summary can be used to show or hide page summary\nExample # {{\u0026lt; section [summary] \u0026gt;}} First Page First page # Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum. Second Page Second Page # Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum. "},{"id":26,"href":"/docs/shortcodes/section/first-page/","title":"First Page","section":"Section","content":" First page # Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.\nDuis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n"},{"id":27,"href":"/docs/shortcodes/section/second-page/","title":"Second Page","section":"Section","content":" Second Page # Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.\nDuis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n"},{"id":28,"href":"/docs/shortcodes/tabs/","title":"Tabs","section":"Shortcodes","content":" Tabs # Tabs let you organize content by context, for example installation instructions for each supported platform.\n{{\u0026lt; tabs \u0026#34;uniqueid\u0026#34; \u0026gt;}} {{\u0026lt; tab \u0026#34;MacOS\u0026#34; \u0026gt;}} # MacOS Content {{\u0026lt; /tab \u0026gt;}} {{\u0026lt; tab \u0026#34;Linux\u0026#34; \u0026gt;}} # Linux Content {{\u0026lt; /tab \u0026gt;}} {{\u0026lt; tab \u0026#34;Windows\u0026#34; \u0026gt;}} # Windows Content {{\u0026lt; /tab \u0026gt;}} {{\u0026lt; /tabs \u0026gt;}} Example # MacOS MacOS # This is tab MacOS content.\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.\nLinux Linux # This is tab Linux content.\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.\nWindows Windows # This is tab Windows content.\nLorem markdownum insigne. Olympo signis Delphis! Retexi Nereius nova develat stringit, frustra Saturnius uteroque inter! Oculis non ritibus Telethusa protulit, sed sed aere valvis inhaesuro Pallas animam: qui quid, ignes. Miseratus fonte Ditis conubia.\n"},{"id":29,"href":"/docs/shortcodes/katex/","title":"KaTeX","section":"Shortcodes","content":" KaTeX # KaTeX shortcode let you render math typesetting in markdown document. See KaTeX\nExample # {{\u0026lt; katex display=true class=\u0026#34;optional\u0026#34; \u0026gt;}} f(x) = \\int_{-\\infty}^\\infty\\hat f(\\xi)\\,e^{2 \\pi i \\xi x}\\,d\\xi {{\u0026lt; /katex \u0026gt;}} \\[f(x) = \\int_{-\\infty}^\\infty\\hat f(\\xi)\\,e^{2 \\pi i \\xi x}\\,d\\xi\\] Display Mode Example # Here is some inline example: \\(\\pi(x)\\) , rendered in the same line. And below is display example, having display: block \\[f(x) = \\int_{-\\infty}^\\infty\\hat f(\\xi)\\,e^{2 \\pi i \\xi x}\\,d\\xi\\] Text continues here.\n"}]
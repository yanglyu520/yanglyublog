<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Introduction on Yang's Blog</title><link>http://localhost:1313/</link><description>Recent content in Introduction on Yang's Blog</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Wed, 10 Jul 2024 00:00:00 +0000</lastBuildDate><atom:link href="http://localhost:1313/index.xml" rel="self" type="application/rss+xml"/><item><title>Variadic Parameters</title><link>http://localhost:1313/docs/golang/basics/variadic/</link><pubDate>Wed, 10 Jul 2024 00:00:00 +0000</pubDate><guid>http://localhost:1313/docs/golang/basics/variadic/</guid><description>Variadic Parameters and Argument Unpacking in Go In Go, variadic parameters and argument unpacking/expanding involve some specific behind-the-scenes mechanisms that allow for flexible and dynamic function calls. Here&amp;rsquo;s a detailed explanation of how these mechanisms work:
Variadic Parameters A variadic parameter allows a function to accept an arbitrary number of arguments. In Go, this is denoted by an ellipsis (...) followed by the type. For example:
func sum(numbers ...int) int { total := 0 for _, number := range numbers { total += number } return total } In this sum function, numbers is a variadic parameter of type int.</description></item><item><title>Closure Functions</title><link>http://localhost:1313/docs/golang/basics/closure/</link><pubDate>Tue, 09 Jul 2024 00:00:00 +0000</pubDate><guid>http://localhost:1313/docs/golang/basics/closure/</guid><description>Understanding Closure Functions in Go In Go, closure functions are powerful constructs that allow functions to capture and remember the variables from their surrounding scope even after that scope has exited. This capability is essential for creating more dynamic, flexible, and maintainable code. Let’s delve into closure functions with a simple example, understand why variables like sum are escaped to the heap, and explore their use cases in the standard library and web API development.</description></item><item><title>Empty Struct</title><link>http://localhost:1313/docs/golang/basics/emptystruct/</link><pubDate>Tue, 09 Jul 2024 00:00:00 +0000</pubDate><guid>http://localhost:1313/docs/golang/basics/emptystruct/</guid><description>Go Empty Struct Introduction An empty struct has zero memory allocation, same memory addresses for multiple instances, and stateless.
Zero Memory Allocation Empty structs do not occupy memory, making them useful for memory optimization:
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;unsafe&amp;#34; ) func main() { var e struct{} fmt.Println(unsafe.Sizeof(e)) // Output: 0 } Same Memory Addresses Multiple empty structs share the same address:
package main import &amp;#34;fmt&amp;#34; func main() { var e, e2 struct{} fmt.</description></item><item><title>Leetcode 202 happy number</title><link>http://localhost:1313/docs/leetcode/data-structure/hashmap/202happynumber/</link><pubDate>Tue, 09 Jul 2024 00:00:00 +0000</pubDate><guid>http://localhost:1313/docs/leetcode/data-structure/hashmap/202happynumber/</guid><description>Leetcode 202 Happy Number A happy number is a number defined by the following process:
Starting with any positive integer, replace the number by the sum of the squares of its digits. Repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy. Return true if n is a happy number, and false if not.</description></item><item><title>Leetcode 242 Valid Anagram</title><link>http://localhost:1313/docs/leetcode/data-structure/hashmap/242validanagram/</link><pubDate>Tue, 09 Jul 2024 00:00:00 +0000</pubDate><guid>http://localhost:1313/docs/leetcode/data-structure/hashmap/242validanagram/</guid><description>Leetcode 242: Valid Anagram In this post, we will discuss how to solve the popular LeetCode problem: &amp;ldquo;Valid Anagram&amp;rdquo;. This problem requires us to determine if two given strings are anagrams of each other. Two strings are anagrams if they contain the same characters with the same frequencies.
Problem Statement Given two strings s and t, write a function isAnagram(s string, t string) bool that returns true if t is an anagram of s, and false otherwise.</description></item><item><title>Leetcode 383 ransom note</title><link>http://localhost:1313/docs/leetcode/data-structure/hashmap/383/</link><pubDate>Tue, 09 Jul 2024 00:00:00 +0000</pubDate><guid>http://localhost:1313/docs/leetcode/data-structure/hashmap/383/</guid><description>Leetcode 383 ransom note Given two strings ransomNote and magazine, return true if ransomNote can be constructed by using the letters from magazine and false otherwise.
Each letter in magazine can only be used once in ransomNote. Answer: I have learnt that we can early return false if letterCount[char-'a'] &amp;lt; 0
func canConstruct(ransomNote string, magazine string) bool { // Create an array to count the occurrences of each letter in the magazine letterCount := [26]int{} for _, char := range magazine { letterCount[char-&amp;#39;a&amp;#39;]++ } // Check if the ransom note can be constructed from the magazine for _, char := range ransomNote { letterCount[char-&amp;#39;a&amp;#39;]-- if letterCount[char-&amp;#39;a&amp;#39;] &amp;lt; 0 { return false } } return true }</description></item><item><title>Leetcode 454 four sum &amp;&amp; Leetcode 15 three sum &amp;&amp;</title><link>http://localhost:1313/docs/leetcode/data-structure/hashmap/two-three-four-sum/</link><pubDate>Tue, 09 Jul 2024 00:00:00 +0000</pubDate><guid>http://localhost:1313/docs/leetcode/data-structure/hashmap/two-three-four-sum/</guid><description>Leetcode 1 two sum func twoSum(nums []int, target int) []int { m := map[int]int{} for i, v := range nums{ another := target - v if index, found := m[another]; found{ return []int{i,index} } m[v]=i } return nil } Leetcode 454. 4Sum II Given four integer arrays nums1, nums2, nums3, and nums4 all of length n, return the number of tuples (i, j, k, l) such that: 0 &amp;lt;= i, j, k, l &amp;lt; n nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0</description></item><item><title>new vs make</title><link>http://localhost:1313/docs/golang/basics/newvsmake/</link><pubDate>Tue, 09 Jul 2024 00:00:00 +0000</pubDate><guid>http://localhost:1313/docs/golang/basics/newvsmake/</guid><description>Difference between new and make in Golang In Go, make and new are built-in functions used for memory allocation.
make not only allocates memory but also initializes the data, which is necessary because the data types supported by make (like slices, maps, and channels) require initialization before use. On the other hand, new allocates memory space that is filled with zero values. new allocates a single block of memory, while make may allocate multiple blocks of memory.</description></item><item><title>What Happens When You Put a URL in Your Browser?</title><link>http://localhost:1313/docs/cs/internet/t2/</link><pubDate>Thu, 20 Jun 2024 00:00:00 +0000</pubDate><guid>http://localhost:1313/docs/cs/internet/t2/</guid><description>What Happens When You Put a URL in Your Browser? Understanding what happens when you type a URL into your browser and hit enter is essential for grasping the basics of web technology. Here’s a detailed step-by-step breakdown of the process.
1. URL Entry and Parsing Input and Validation: When you enter a URL in the address bar, the browser first validates the URL to ensure it&amp;rsquo;s properly formatted. Protocol Identification: The browser identifies the protocol (e.</description></item><item><title>What Happens When You Put a URL in Your Browser?</title><link>http://localhost:1313/docs/cs/operating-system/t2/</link><pubDate>Thu, 20 Jun 2024 00:00:00 +0000</pubDate><guid>http://localhost:1313/docs/cs/operating-system/t2/</guid><description>What Happens When You Put a URL in Your Browser? Understanding what happens when you type a URL into your browser and hit enter is essential for grasping the basics of web technology. Here’s a detailed step-by-step breakdown of the process.
1. URL Entry and Parsing Input and Validation: When you enter a URL in the address bar, the browser first validates the URL to ensure it&amp;rsquo;s properly formatted. Protocol Identification: The browser identifies the protocol (e.</description></item><item><title>What Happens When You Put a URL in Your Browser?</title><link>http://localhost:1313/docs/cs/relational-db/t2/</link><pubDate>Thu, 20 Jun 2024 00:00:00 +0000</pubDate><guid>http://localhost:1313/docs/cs/relational-db/t2/</guid><description>What Happens When You Put a URL in Your Browser? Understanding what happens when you type a URL into your browser and hit enter is essential for grasping the basics of web technology. Here’s a detailed step-by-step breakdown of the process.
1. URL Entry and Parsing Input and Validation: When you enter a URL in the address bar, the browser first validates the URL to ensure it&amp;rsquo;s properly formatted. Protocol Identification: The browser identifies the protocol (e.</description></item><item><title>fmt package</title><link>http://localhost:1313/docs/golang/basics/fmt/</link><pubDate>Tue, 28 May 2024 00:00:00 +0000</pubDate><guid>http://localhost:1313/docs/golang/basics/fmt/</guid><description>formatting verbs %s vs %q? Answer: %s prints the string without enclosing it in quotes. %q prints the string enclosed in double quotes, %q can print string, byte slice, runes and int. %v vs %+v vs %#v? Answer: %v: Default format, prints the value as is. For structs, it prints only the field values. %+v: Detailed format, includes field names in structs. %#v: Go-syntax representation, includes type information and can be used to recreate the value in Go code.</description></item><item><title>Implement set using map</title><link>http://localhost:1313/docs/golang/basics/set/</link><pubDate>Tue, 28 May 2024 00:00:00 +0000</pubDate><guid>http://localhost:1313/docs/golang/basics/set/</guid><description>How to Implement Set Using hMap in Golang 1. What is a Set? How is Set Different from HashMap? A set is a data structure that stores a collection of unique elements. Sets do not allow duplicate values and do not maintain any particular order of the elements.
A hashmap is a data structure that stores key-value pairs. Each key in a hashmap is unique, and it maps to a specific value.</description></item><item><title>Quick tutorial on blog web with hugo and netlify</title><link>http://localhost:1313/posts/hugosite/</link><pubDate>Tue, 28 May 2024 00:00:00 +0000</pubDate><guid>http://localhost:1313/posts/hugosite/</guid><description>How to Create a Blog with Hugo and Deploy on Netlify Creating a blog with Hugo and deploying it on Netlify is a streamlined and efficient process. Hugo is a powerful static site generator that allows for quick and easy website development. Netlify provides seamless deployment and hosting for static sites. Here&amp;rsquo;s a step-by-step guide to get your blog up and running.
Prerequisites Install Hugo by following the installation guide. Start from the root folder of a github repo, such as yangblog Step 1: Create a New Hugo Site Start by creating a new Hugo site:</description></item><item><title>Setting Up a New Domain for Your Netlify Website</title><link>http://localhost:1313/posts/domain/</link><pubDate>Tue, 28 May 2024 00:00:00 +0000</pubDate><guid>http://localhost:1313/posts/domain/</guid><description>Setting Up a New Domain for Your Netlify Website Setting up a custom domain for your Netlify website helps in branding and makes it easier for users to find your site. Here’s a step-by-step guide on how to set up a new domain for your Netlify website.
Step 1: Purchase a Domain First, you need to purchase a domain from a domain registrar. Some popular domain registrars include:
Namecheap GoDaddy Google Domains Choose a domain name that reflects your brand or website’s purpose.</description></item></channel></rss>
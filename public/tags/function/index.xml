<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Function on Yang's Blog</title><link>http://localhost:1313/tags/function/</link><description>Recent content in Function on Yang's Blog</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Wed, 10 Jul 2024 00:00:00 +0000</lastBuildDate><atom:link href="http://localhost:1313/tags/function/index.xml" rel="self" type="application/rss+xml"/><item><title>Variadic Parameters and Argument Unpacking in Go</title><link>http://localhost:1313/docs/golang/basics/variadic/</link><pubDate>Wed, 10 Jul 2024 00:00:00 +0000</pubDate><guid>http://localhost:1313/docs/golang/basics/variadic/</guid><description>Variadic Parameters and Argument Unpacking in Go # In Go, variadic parameters and argument unpacking/expanding involve some specific behind-the-scenes mechanisms that allow for flexible and dynamic function calls. Here&amp;rsquo;s a detailed explanation of how these mechanisms work:
Variadic Parameters # A variadic parameter allows a function to accept an arbitrary number of arguments. In Go, this is denoted by an ellipsis (...) followed by the type. For example:
func sum(numbers .</description></item><item><title>Understanding Closure Functions in Go</title><link>http://localhost:1313/docs/golang/basics/closure/</link><pubDate>Tue, 09 Jul 2024 00:00:00 +0000</pubDate><guid>http://localhost:1313/docs/golang/basics/closure/</guid><description>Understanding Closure Functions in Go # In Go, closure functions are powerful constructs that allow functions to capture and remember the variables from their surrounding scope even after that scope has exited. This capability is essential for creating more dynamic, flexible, and maintainable code. Letâ€™s delve into closure functions with a simple example, understand why variables like sum are escaped to the heap, and explore their use cases in the standard library and web API development.</description></item></channel></rss>
<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Golang on Yang's Blog</title><link>http://localhost:1313/tags/golang/</link><description>Recent content in Golang on Yang's Blog</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Wed, 10 Jul 2024 00:00:00 +0000</lastBuildDate><atom:link href="http://localhost:1313/tags/golang/index.xml" rel="self" type="application/rss+xml"/><item><title>Variadic Parameters</title><link>http://localhost:1313/docs/golang/basics/variadic/</link><pubDate>Wed, 10 Jul 2024 00:00:00 +0000</pubDate><guid>http://localhost:1313/docs/golang/basics/variadic/</guid><description>Variadic Parameters and Argument Unpacking in Go # In Go, variadic parameters and argument unpacking/expanding involve some specific behind-the-scenes mechanisms that allow for flexible and dynamic function calls. Here&amp;rsquo;s a detailed explanation of how these mechanisms work:
Variadic Parameters # A variadic parameter allows a function to accept an arbitrary number of arguments. In Go, this is denoted by an ellipsis (...) followed by the type. For example:
func sum(numbers .</description></item><item><title>Closure Functions</title><link>http://localhost:1313/docs/golang/basics/closure/</link><pubDate>Tue, 09 Jul 2024 00:00:00 +0000</pubDate><guid>http://localhost:1313/docs/golang/basics/closure/</guid><description>Understanding Closure Functions in Go # In Go, closure functions are powerful constructs that allow functions to capture and remember the variables from their surrounding scope even after that scope has exited. This capability is essential for creating more dynamic, flexible, and maintainable code. Letâ€™s delve into closure functions with a simple example, understand why variables like sum are escaped to the heap, and explore their use cases in the standard library and web API development.</description></item><item><title>Empty Struct</title><link>http://localhost:1313/docs/golang/basics/emptystruct/</link><pubDate>Tue, 09 Jul 2024 00:00:00 +0000</pubDate><guid>http://localhost:1313/docs/golang/basics/emptystruct/</guid><description>Go Empty Struct # Introduction # An empty struct has zero memory allocation, same memory addresses for multiple instances, and stateless.
Zero Memory Allocation # Empty structs do not occupy memory, making them useful for memory optimization:
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;unsafe&amp;#34; ) func main() { var e struct{} fmt.Println(unsafe.Sizeof(e)) // Output: 0 } Same Memory Addresses # Multiple empty structs share the same address:
package main import &amp;#34;fmt&amp;#34; func main() { var e, e2 struct{} fmt.</description></item><item><title>new vs make</title><link>http://localhost:1313/docs/golang/basics/newvsmake/</link><pubDate>Tue, 09 Jul 2024 00:00:00 +0000</pubDate><guid>http://localhost:1313/docs/golang/basics/newvsmake/</guid><description>Difference between new and make in Golang # In Go, make and new are built-in functions used for memory allocation.
make not only allocates memory but also initializes the data, which is necessary because the data types supported by make (like slices, maps, and channels) require initialization before use. On the other hand, new allocates memory space that is filled with zero values. new allocates a single block of memory, while make may allocate multiple blocks of memory.</description></item><item><title>fmt package</title><link>http://localhost:1313/docs/golang/basics/fmt/</link><pubDate>Tue, 28 May 2024 00:00:00 +0000</pubDate><guid>http://localhost:1313/docs/golang/basics/fmt/</guid><description>formatting verbs # %s vs %q? Answer: %s prints the string without enclosing it in quotes. %q prints the string enclosed in double quotes, %q can print string, byte slice, runes and int. %v vs %+v vs %#v? Answer: %v: Default format, prints the value as is. For structs, it prints only the field values. %+v: Detailed format, includes field names in structs. %#v: Go-syntax representation, includes type information and can be used to recreate the value in Go code.</description></item><item><title>Implement set using map</title><link>http://localhost:1313/docs/golang/basics/set/</link><pubDate>Tue, 28 May 2024 00:00:00 +0000</pubDate><guid>http://localhost:1313/docs/golang/basics/set/</guid><description>How to Implement Set Using hMap in Golang # 1. What is a Set? How is Set Different from HashMap? # A set is a data structure that stores a collection of unique elements. Sets do not allow duplicate values and do not maintain any particular order of the elements.
A hashmap is a data structure that stores key-value pairs. Each key in a hashmap is unique, and it maps to a specific value.</description></item></channel></rss>
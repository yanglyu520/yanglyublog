<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Yang's Blog</title><link>http://localhost:1313/docs/leetcode/data-structure/hashmap/</link><description>Recent content on Yang's Blog</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Tue, 09 Jul 2024 00:00:00 +0000</lastBuildDate><atom:link href="http://localhost:1313/docs/leetcode/data-structure/hashmap/index.xml" rel="self" type="application/rss+xml"/><item><title>Leetcode 202 happy number</title><link>http://localhost:1313/docs/leetcode/data-structure/hashmap/202happynumber/</link><pubDate>Tue, 09 Jul 2024 00:00:00 +0000</pubDate><guid>http://localhost:1313/docs/leetcode/data-structure/hashmap/202happynumber/</guid><description>Leetcode 202 Happy Number A happy number is a number defined by the following process:
Starting with any positive integer, replace the number by the sum of the squares of its digits. Repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy. Return true if n is a happy number, and false if not.</description></item><item><title>Leetcode 242 Valid Anagram</title><link>http://localhost:1313/docs/leetcode/data-structure/hashmap/242validanagram/</link><pubDate>Tue, 09 Jul 2024 00:00:00 +0000</pubDate><guid>http://localhost:1313/docs/leetcode/data-structure/hashmap/242validanagram/</guid><description>Leetcode 242: Valid Anagram In this post, we will discuss how to solve the popular LeetCode problem: &amp;ldquo;Valid Anagram&amp;rdquo;. This problem requires us to determine if two given strings are anagrams of each other. Two strings are anagrams if they contain the same characters with the same frequencies.
Problem Statement Given two strings s and t, write a function isAnagram(s string, t string) bool that returns true if t is an anagram of s, and false otherwise.</description></item><item><title>Leetcode 383 ransom note</title><link>http://localhost:1313/docs/leetcode/data-structure/hashmap/383/</link><pubDate>Tue, 09 Jul 2024 00:00:00 +0000</pubDate><guid>http://localhost:1313/docs/leetcode/data-structure/hashmap/383/</guid><description>Leetcode 383 ransom note Given two strings ransomNote and magazine, return true if ransomNote can be constructed by using the letters from magazine and false otherwise.
Each letter in magazine can only be used once in ransomNote. Answer: I have learnt that we can early return false if letterCount[char-'a'] &amp;lt; 0
func canConstruct(ransomNote string, magazine string) bool { // Create an array to count the occurrences of each letter in the magazine letterCount := [26]int{} for _, char := range magazine { letterCount[char-&amp;#39;a&amp;#39;]++ } // Check if the ransom note can be constructed from the magazine for _, char := range ransomNote { letterCount[char-&amp;#39;a&amp;#39;]-- if letterCount[char-&amp;#39;a&amp;#39;] &amp;lt; 0 { return false } } return true }</description></item><item><title>Leetcode 454 four sum &amp;&amp; Leetcode 15 three sum &amp;&amp;</title><link>http://localhost:1313/docs/leetcode/data-structure/hashmap/two-three-four-sum/</link><pubDate>Tue, 09 Jul 2024 00:00:00 +0000</pubDate><guid>http://localhost:1313/docs/leetcode/data-structure/hashmap/two-three-four-sum/</guid><description>Leetcode 1 two sum func twoSum(nums []int, target int) []int { m := map[int]int{} for i, v := range nums{ another := target - v if index, found := m[another]; found{ return []int{i,index} } m[v]=i } return nil } Leetcode 454. 4Sum II Given four integer arrays nums1, nums2, nums3, and nums4 all of length n, return the number of tuples (i, j, k, l) such that: 0 &amp;lt;= i, j, k, l &amp;lt; n nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0</description></item></channel></rss>